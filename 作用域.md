### 作用域
* 引擎：从头到尾负责整个JavaScript程序的编译及执行过程。
* 编译器：负责语法分析及代码生成。
* 作用域：存储变量和查找变量的规则。

### 词法作用域 vs 动态作用域
* 词法作用域 （静态作用域）  
作用域在词法分析阶段（定义阶段）就确定了，不会改变。关注函数在何处声明。  
作用域查找规则：始终从运行时所处的最内部作用域开始，逐级向外或者向上进行，直到遇见第一个匹配的标识符为止。
* 动态作用域  
在运行时根据程序的流程信息来动态确定的。关注函数在何处调用。

```
var a = 2;

function foo() {
  console.log(a); // 会输出2还是3？
}

function bar() {
  var a = 3;
  foo();
}

bar();

```
依据规则为词法作用域： a为2   
依据规则为动态作用域： a为3   
js并不具备动态作用域，只有词法作用域。但是eval,with,this机制像动态作用域。


### 函数作用域   
属于这个函数的全部变量可以在整个函数范围内使用及复用。外部作用域无法访问函数内部的任何内容。   

### 函数   
#### 函数定义方式   
* 函数声明：function sum(){} 函数声明提前
* 函数表达式： var sum = function(){}

#### 没有重载
函数重载：在同一个作用域下，函数名相同，参数不同。
在js中，两个同名函数，后面的函数会覆盖前面的函数。

#### 匿名函数表达式
function(){}... 没有名称标识符。函数表达式可以是匿名的，函数声明不可以省略函数名。

#### 立即执行函数表达式IIFE
(function(){})() 或者(function(){}())
通常对匿名函数使用立即执行函数表达式。
* 立即执行函数表达式内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。
* 不必为函数命名，避免污染了全局变量。


### 块作用域
ES5中没有块作用域的概念。   
for(var i =0; i<10; i++){console.log(i)}  ---> i 是全局变量   
var foo = true; if(foo){var bar = foo*2}  ---> bar是全局变量   
我们本意是想只在for循环内部的上下文或者if声明的上下文能使用所定义的i,bar变量。但是使用了var声明，i,bar变量都被绑定在外部作用域（函数或者全局）中。   
但是try{}catch{} catch分句中有块作用域。   

----> ES6中引入了块作用域 let/const    
let 将变量绑定到所在的任意作用域中。通常是{}内部。   
但使用let声明的变量不会在块作用域中进行声明提升。 

### 提升
引擎会在解释JavaScript代码之前首先会对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。
所以变量和函数的所有声明会在任何代码被执行前首先处理。   
只有声明本身会提升，而赋值和其他运行逻辑会留在原地。   
函数声明会提升，但是函数表达式不会提升。

```
    foo();
    bar();
    var foo = function bar(){};
```
声明提前后：
```
 var foo;
 foo(); // TypeError
 bar(); // ReferenceError
 foo = function bar(){};
```

函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。

PS: 参照 《你不知道的JavaScript上》





