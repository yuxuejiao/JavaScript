### 闭包
闭包：函数可以 ***记住并访问*** 所在的词法作用域时，就产生了闭包。即使函数是在当前词法作用域之外执行。
闭包的本质：词法作用域和函数当作值传递。 
eg: 
```
function foo() {    
    var a = 2; 
 
    function bar() {         
        console.log( a++ ); // 2     
    } 
 
    bar(); 
} 
foo(); // 2
foo(); // 2

```
这个不是闭包，当第一个foo执行完毕后，foo和bar函数都执行完毕，所以foo和bar作用域都被销毁了。其中的变量a被回收。

eg： 
```
function foo() {    
    var a = 2; 
 
    function bar() {         
        console.log( a++ ); // 2     
    } 
 
    return bar;
} 
var baz = foo();
baz(); // 2
baz(); // 3
foo = null; 
baz(); // 4
baz = null;
baz; // null

```
这个是闭包。
执行 `var baz = foo();`，从而baz变量引用内部的函数bar。而bar引用了foo的作用域，从而执行foo()，foo作用域没有被销毁。
??? foo作用域一直被保留，从而变量a的值一直被保留。???

注意点： 
* var baz = foo() 是值传递还是引用传递？ 值传递？ 为什么？
* foo = null; foo作用域被强制销毁，变量a？？？ 变量a被bar函数引用，所以没有被清空。

