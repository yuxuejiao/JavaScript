### 闭包
闭包：函数可以 ***记住并访问*** 所在的词法作用域时，就产生了闭包。即使函数是在当前词法作用域之外执行。   
闭包的本质：词法作用域和函数当作值传递。   
eg: 
```
function foo() {    
    var a = 2; 
 
    function bar() {         
        console.log( a++ ); // 2     
    } 
 
    bar(); 
} 
foo(); // 2
foo(); // 2

```
这个不是闭包，当第一个foo执行完毕后，foo和bar函数都执行完毕，所以foo和bar作用域链都被销毁了。其中的变量a被回收。

eg： 
```
var a = 3;
function foo() {    
    var a = 2; 
 
    function bar() {         
        console.log( a++ ); // 2     
    } 
 
    return bar;
} 
var baz = foo();
baz(); // 2
baz(); // 3
baz(); // 4
baz = null;
baz; // null

```
这个是闭包。

详解： 
作用域链的图
![avatar](/scope chain.jpg)
在定义foo()函数时，会创建一个包含全局变量对象的作用域链， 这个作用域链会保存在内部的[[Scope]]属性中。   
当执行 var baz = foo()这行代码时，即调用foo()函数时，会为函数创建一个执行环境，首先复制[[Scope]]属性中的作用域链。此后会将活动对象被创建并推入执行环境作用域链的前端。作用域链是一个指向变量对象的指针列表，只引用但不是实际包含变量对象。   
一般情况，函数执行完毕，局部活动对象就会被销毁。内存中仅包含全局作用域（全局执行环境的变量对象）。   
但是在闭包中，foo()调用后，foo执行环境的作用域链被销毁，但是其活动对象依然留在内存中。因为此时baz引用bar函数，bar函数的作用域链在引用这个活动对象。从而调用baz多次，一直引用的都是同一个变量对象a，从而a的值不断递增。   
只有当设置baz = null，解除baz对bar的引用，从而bar的作用域链被销毁。从而活动对象a被回收。


### 执行环境、作用域链、垃圾回收
执行环境：定义了变量或函数有权访问的其他数据。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。
全局执行环境是最外围的一个执行环境。在web中，window是全局执行环境，因此所有全局变量和函数都是作为window对象的属性和方法创建的。   

***某个执行环境的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出 - 例如关闭网页或浏览器 - 时才会被销毁）***  

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。    

作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。   

内部环境可以通过作用域链访问所有的外部环境，但 外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

垃圾回收： 对象有没有其他对象引用它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。   

PS: 参照 《JS高级程序设计》
